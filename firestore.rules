
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    function isAdmin() {
      // For client-side initiated actions where request.auth is available.
      // This will NOT work reliably for server actions if request.auth is null when rules are evaluated.
      let adminEmails = ['tumbikarthik2797@gmail.com','deepakperumal09@gmail.com']; // Ensure this matches your ADMIN_EMAIL constant
      return request.auth != null && request.auth.token.email in adminEmails;
    }

    // Function to check for essential fields in a new booking
    function hasSufficientBookingDataForCreate(data) {
      return data.name is string && data.name.size() > 0 &&
             data.email is string && data.email.size() > 0 && 
             data.phone is string && data.phone.size() > 0 &&
             data.serviceType is string && data.serviceType.size() > 0 &&
             data.preferredDate is timestamp && // Ensure server action sends it as a Firestore Timestamp
             data.preferredTime is string && data.preferredTime.size() > 0 &&
             data.userEmail is string && data.userEmail.size() > 0 && // This is the validated email from form, set by server action
             data.status is string && data.status.size() > 0 &&
             data.bookedAt != null && // This will be a serverTimestamp placeholder during rule evaluation
             data.displayId is string && data.displayId.size() > 0;
    }

    // Users collection:
    // - A user can read, create, and update their own profile.
    match /users/{userId} {
      allow read, create, update: if request.auth != null && request.auth.uid == userId;
    }

    // Service Bookings collection:
    match /serviceBookings/{bookingId} {
      // CREATE:
      // Allows creation if essential fields are present.
      // The server action is responsible for setting these fields (including userEmail).
      // Client-side logic in ServiceBookingForm.tsx should ensure only logged-in users
      // can trigger this server action.
      allow create: if hasSufficientBookingDataForCreate(request.resource.data);

      // READ: Users can read their own bookings. Admins can read any booking.
      // This relies on request.auth, which might be null for server actions.
      // If read operations from server actions fail, this rule may need further adjustment.
      allow read: if request.auth != null && (resource.data.userEmail == request.auth.token.email || isAdmin());

      // UPDATE (e.g., status by admin):
      // This relies on request.auth and isAdmin(), might be null for server actions.
      // If update operations from server actions fail, this rule may need further adjustment.
      allow update: if request.auth != null && isAdmin();

      // Deletion can be restricted, e.g., only by admins or not at all.
      // allow delete: if request.auth != null && isAdmin();
    }

    // LIST operation for queries (e.g., getUserBookings, getAllBookings)
    // The documents returned are still subject to the per-document 'read' rule.
    // This also relies on request.auth.
    match /serviceBookings/{document=**} {
      allow list: if request.auth != null;
    }

    // The '/counters/serviceBookingCounter' rule is no longer needed as ID generation changed.
  }
}
